{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to KFS","text":"<p>KFS (Kernel From Scratch) is a long-term educational project developed at 42 Wolfsburg that explores the foundations of operating system design by building a kernel step by step, starting from nothing. Rather than relying on existing kernels or high-level abstractions, this project focuses on understanding how things actually work at the lowest level of a computer system.</p> <p>The project is divided into multiple stages (kfs-1 to kfs-x), each introducing new core concepts such as booting, memory management, interrupts, multitasking, and hardware interaction. Every stage builds upon the previous one, gradually transforming a minimal bootable binary into a functional and extensible kernel.</p> <p>KFS currently features:</p> <ul> <li> GDT setup</li> <li> Framebuffer output</li> <li> Paging</li> <li> Preemptive multitasking</li> <li> Reentrancy</li> <li> ATA disk support</li> <li> FPU (Lazy context switching)</li> <li> VFS</li> <li> Ext2 filesystem support</li> <li> Device files</li> <li> Procfs, Sysfs</li> <li> Userspace programs</li> <li> TTY subsystem</li> <li> VT Parsing</li> <li> Kernel modules</li> <li> Standard POSIX Signals</li> <li> IPC with socketpairs and Unix pipes.</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>make</code> - Compile the project</li> <li><code>make qemu</code> - Compile and run the project</li> <li><code>make clean</code> - Remove the kernel binary.</li> <li><code>make fclean</code> - Remove the kernel binary, iso and all other compilation generated files.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>docs/ # Documentation\n    kfs/\n        docs\niso # ISO configuration files\n    boot/\n        grub/\nsrc/ # Source code\n    arch/\n        x86/\n            boot/\n            mm/\n            system/\n    debug/\n    drivers/\n    kernel/\n        irq/\n        mm/\n        sched/\n        syscalls/\n        time/\n        userspace/\n        utils/\n    mm/\n    userspace/\nuserspace # Zig userspace programs\n    src\nzig-out # Kernel binary output directory\n    bin\n</code></pre>"},{"location":"about/","title":"About","text":"<p>This project is part of the KFS (Kernel From Scratch) series at 42 Wolfsburg. The goal of the project is to explore operating system development by building a kernel incrementally from scratch, focusing on low-level concepts such as booting, memory management, and CPU interaction</p> <p>This documentation is written as a companion to the codebase. It is intended for:</p> <ul> <li>The project authors, as a long-term reference</li> <li>42 students working on or reviewing KFS</li> <li>Anyone interested in low-level systems programming</li> </ul> <p>Contributors:</p> <ul> <li>Polina Simonenko</li> <li>Vasileios Almpanis</li> </ul>"},{"location":"core/","title":"Core","text":""},{"location":"libc/","title":"KFS compatibility with LibC","text":"<p>In our attempt to support LibC these are the system calls that can be used.</p> <ul> <li> SYS_accept</li> <li> SYS_accept4</li> <li> SYS_access</li> <li> SYS_acct</li> <li> SYS_adjtimex</li> <li> SYS_arch_prctl</li> <li> SYS_brk</li> <li> SYS_cachectl</li> <li> SYS_cacheflush</li> <li> SYS_capget</li> <li> SYS_capset</li> <li> SYS_chdir</li> <li> SYS_chmod</li> <li> SYS_chown</li> <li> SYS_chown32</li> <li> SYS_chroot</li> <li> SYS_clock_adjtime</li> <li> SYS_clock_adjtime64</li> <li> SYS_clock_getres</li> <li> SYS_clock_getres_time32</li> <li> SYS_clock_getres_time64</li> <li> SYS_clock_gettime</li> <li> SYS_clock_gettime32</li> <li> SYS_clock_gettime64</li> <li> SYS_clock_nanosleep</li> <li> SYS_clock_nanosleep_time32</li> <li> SYS_clock_nanosleep_time64</li> <li> SYS_clock_settime</li> <li> SYS_clock_settime32</li> <li> SYS_clock_settime64</li> <li> SYS_clone</li> <li> SYS_close</li> <li> SYS_copy_file_range</li> <li> SYS_finit_module</li> <li> SYS_delete_module</li> <li> SYS_dup</li> <li> SYS_dup2</li> <li> SYS_dup3</li> <li> SYS_epoll_create</li> <li> SYS_epoll_create1</li> <li> SYS_epoll_ctl</li> <li> SYS_epoll_pwait</li> <li> SYS_epoll_wait</li> <li> SYS_eventfd</li> <li> SYS_eventfd2</li> <li> SYS_execve</li> <li> SYS_execveat</li> <li> SYS_exit</li> <li> SYS_exit_group</li> <li> SYS_faccessat</li> <li> SYS_faccessat2</li> <li> SYS_fadvise</li> <li> SYS_fadvise64</li> <li> SYS_fadvise64_64</li> <li> SYS_fallocate</li> <li> SYS_fanotify_init</li> <li> SYS_fanotify_mark</li> <li> SYS_fchdir</li> <li> SYS_fchmod</li> <li> SYS_fchmodat</li> <li> SYS_fchmodat2</li> <li> SYS_fchown</li> <li> SYS_fchown32</li> <li> SYS_fchownat</li> <li> SYS_fcntl</li> <li> SYS_fcntl64</li> <li> SYS_fdatasync</li> <li> SYS_fgetxattr</li> <li> SYS_flistxattr</li> <li> SYS_flock</li> <li> SYS_fork</li> <li> SYS_fremovexattr</li> <li> SYS_fsetxattr</li> <li> SYS_fstat</li> <li> SYS_fstat64</li> <li> SYS_fstatat</li> <li> SYS_fstatat64</li> <li> SYS_fstatfs</li> <li> SYS_fstatfs64</li> <li> SYS_fsync</li> <li> SYS_ftruncate</li> <li> SYS_ftruncate64</li> <li> SYS_futex</li> <li> SYS_futex_time64</li> <li> SYS_futimesat</li> <li> SYS_get_robust_list</li> <li> SYS_getcpu</li> <li> SYS_getcwd</li> <li> SYS_getdents</li> <li> SYS_getdents64</li> <li> SYS_getegid</li> <li> SYS_getegid32</li> <li> SYS_geteuid</li> <li> SYS_geteuid32</li> <li> SYS_getgid</li> <li> SYS_getgid32</li> <li> SYS_getgroups</li> <li> SYS_getgroups32</li> <li> SYS_getitimer</li> <li> SYS_getpgid</li> <li> SYS_getpid</li> <li> SYS_getppid</li> <li> SYS_getpriority</li> <li> SYS_getrandom</li> <li> SYS_getresgid</li> <li> SYS_getresgid32</li> <li> SYS_getresuid</li> <li> SYS_getresuid32</li> <li> SYS_getrlimit</li> <li> SYS_getrusage</li> <li> SYS_getrusage_time64</li> <li> SYS_getsid</li> <li> SYS_gettid</li> <li> SYS_gettimeofday</li> <li> SYS_gettimeofday_time32</li> <li> SYS_getuid</li> <li> SYS_getuid32</li> <li> SYS_getxattr</li> <li> SYS_init_module</li> <li> SYS_inotify_add_watch</li> <li> SYS_inotify_init</li> <li> SYS_inotify_init1</li> <li> SYS_inotify_rm_watch</li> <li> SYS_ioctl</li> <li> SYS_ioperm</li> <li> SYS_iopl</li> <li> SYS_ipc</li> <li> SYS_kill</li> <li> SYS_lchown</li> <li> SYS_lchown32</li> <li> SYS_lgetxattr</li> <li> SYS_link</li> <li> SYS_linkat</li> <li> SYS_listxattr</li> <li> SYS_llistxattr</li> <li> SYS_lremovexattr</li> <li> SYS_lseek</li> <li> SYS_llseek</li> <li> SYS_lsetxattr</li> <li> SYS_lstat</li> <li> SYS_lstat64</li> <li> SYS_madvise</li> <li> SYS_membarrier</li> <li> SYS_memfd_create</li> <li> SYS_mincore</li> <li> SYS_mkdir</li> <li> SYS_mkdirat</li> <li> SYS_mknod</li> <li> SYS_mknodat</li> <li> SYS_mlock</li> <li> SYS_mlock2</li> <li> SYS_mlockall</li> <li> SYS_mmap</li> <li> SYS_mmap2</li> <li> SYS_mount</li> <li> SYS_mprotect</li> <li> SYS_mq_getsetattr</li> <li> SYS_mq_notify</li> <li> SYS_mq_open</li> <li> SYS_mq_timedreceive</li> <li> SYS_mq_timedreceive_time64</li> <li> SYS_mq_timedsend</li> <li> SYS_mq_timedsend_time64</li> <li> SYS_mq_unlink</li> <li> SYS_mremap</li> <li> SYS_msgctl</li> <li> SYS_msgget</li> <li> SYS_msgrcv</li> <li> SYS_msgsnd</li> <li> SYS_msync</li> <li> SYS_munlock</li> <li> SYS_munlockall</li> <li> SYS_munmap</li> <li> SYS_name_to_handle_at</li> <li> SYS_nanosleep</li> <li> SYS_newfstatat</li> <li> SYS_open</li> <li> SYS_open_by_handle_at</li> <li> SYS_openat</li> <li> SYS_pause</li> <li> SYS_personality</li> <li> SYS_pipe</li> <li> SYS_pipe2</li> <li> SYS_pivot_root</li> <li> SYS_poll</li> <li> SYS_ppoll</li> <li> SYS_ppoll_time64</li> <li> SYS_prctl</li> <li> SYS_pread</li> <li> SYS_pread64</li> <li> SYS_preadv</li> <li> SYS_preadv2</li> <li> SYS_prlimit64</li> <li> SYS_process_vm_readv</li> <li> SYS_process_vm_writev</li> <li> SYS_pselect6</li> <li> SYS_pselect6_time64</li> <li> SYS_ptrace</li> <li> SYS_pwrite</li> <li> SYS_pwrite64</li> <li> SYS_pwritev</li> <li> SYS_pwritev2</li> <li> SYS_quotactl</li> <li> SYS_read</li> <li> SYS_readahead</li> <li> SYS_readlink</li> <li> SYS_readlinkat</li> <li> SYS_readv</li> <li> SYS_reboot</li> <li> SYS_recvmmsg</li> <li> SYS_recvmmsg_time64</li> <li> SYS_remap_file_pages</li> <li> SYS_removexattr</li> <li> SYS_rename</li> <li> SYS_renameat</li> <li> SYS_renameat2</li> <li> SYS_rmdir</li> <li> SYS_rt_sigaction</li> <li> SYS_rt_sigpending</li> <li> SYS_rt_sigprocmask</li> <li> SYS_rt_sigqueueinfo</li> <li> SYS_rt_sigreturn</li> <li> SYS_rt_sigsuspend</li> <li> SYS_rt_sigtimedwait</li> <li> SYS_rt_sigtimedwait_time64</li> <li> SYS_sched_get_priority_max</li> <li> SYS_sched_get_priority_min</li> <li> SYS_sched_getaffinity</li> <li> SYS_sched_getparam</li> <li> SYS_sched_getscheduler</li> <li> SYS_sched_rr_get_interval</li> <li> SYS_sched_rr_get_interval_time64</li> <li> SYS_sched_setaffinity</li> <li> SYS_sched_setparam</li> <li> SYS_sched_setscheduler</li> <li> SYS_sched_yield</li> <li> SYS_select</li> <li> SYS_semctl</li> <li> SYS_semget</li> <li> SYS_semop</li> <li> SYS_semtimedop</li> <li> SYS_semtimedop_time64</li> <li> SYS_sendfile</li> <li> SYS_sendfile64</li> <li> SYS_sendmmsg</li> <li> SYS_set_robust_list</li> <li> SYS_set_thread_area</li> <li> SYS_set_tid_address</li> <li> SYS_setdomainname</li> <li> SYS_setfsgid</li> <li> SYS_setfsgid32</li> <li> SYS_setfsuid</li> <li> SYS_setfsuid32</li> <li> SYS_setgid</li> <li> SYS_setgid32</li> <li> SYS_setgroups</li> <li> SYS_setgroups32</li> <li> SYS_sethostname</li> <li> SYS_setitimer</li> <li> SYS_setns</li> <li> SYS_setpgid</li> <li> SYS_setpriority</li> <li> SYS_setregid</li> <li> SYS_setregid32</li> <li> SYS_setresgid</li> <li> SYS_setresgid32</li> <li> SYS_setresuid</li> <li> SYS_setresuid32</li> <li> SYS_setreuid</li> <li> SYS_setreuid32</li> <li> SYS_setrlimit</li> <li> SYS_setsid</li> <li> SYS_settimeofday</li> <li> SYS_settimeofday_time32</li> <li> SYS_setuid</li> <li> SYS_setuid32</li> <li> SYS_setxattr</li> <li> SYS_shmat</li> <li> SYS_shmctl</li> <li> SYS_shmdt</li> <li> SYS_shmget</li> <li> SYS_sigaltstack</li> <li> SYS_signalfd</li> <li> SYS_signalfd4</li> <li> SYS_socketcall</li> <li> SYS_splice</li> <li> SYS_stat</li> <li> SYS_stat64</li> <li> SYS_statfs</li> <li> SYS_statfs64</li> <li> SYS_statx</li> <li> SYS_swapoff</li> <li> SYS_swapon</li> <li> SYS_symlink</li> <li> SYS_symlinkat</li> <li> SYS_sync</li> <li> SYS_sync_file_range</li> <li> SYS_sync_file_range2</li> <li> SYS_syncfs</li> <li> SYS_sysinfo</li> <li> SYS_syslog</li> <li> SYS_tee</li> <li> SYS_timer_create</li> <li> SYS_timer_delete</li> <li> SYS_timer_getoverrun</li> <li> SYS_timer_gettime</li> <li> SYS_timer_gettime32</li> <li> SYS_timer_gettime64</li> <li> SYS_timer_settime</li> <li> SYS_timer_settime32</li> <li> SYS_timer_settime64</li> <li> SYS_timerfd_create</li> <li> SYS_timerfd_gettime</li> <li> SYS_timerfd_gettime32</li> <li> SYS_timerfd_gettime64</li> <li> SYS_timerfd_settime</li> <li> SYS_timerfd_settime32</li> <li> SYS_timerfd_settime64</li> <li> SYS_times</li> <li> SYS_tkill</li> <li> SYS_truncate</li> <li> SYS_truncate64</li> <li> SYS_ugetrlimit</li> <li> SYS_umask</li> <li> SYS_umount</li> <li> SYS_umount2</li> <li> SYS_uname</li> <li> SYS_unlink</li> <li> SYS_unlinkat</li> <li> SYS_unshare</li> <li> SYS_utimensat</li> <li> SYS_utimensat_time64</li> <li> SYS_utimes</li> <li> SYS_vfork</li> <li> SYS_vhangup</li> <li> SYS_vmsplice</li> <li> SYS_wait4</li> <li> SYS_wait4_time64</li> <li> SYS_waitid</li> <li> SYS_write</li> <li> SYS_writev</li> </ul>"},{"location":"locking/","title":"Locking","text":"<p>Locking primitives are essential for synchronizing access to shared resources in a multi-tasking kernel environment.</p>"},{"location":"locking/#mutex","title":"Mutex","text":"<p>A mutex (mutual exclusion) is a synchronization primitive used to protect shared data from being simultaneously accessed by multiple tasks. In KFS, the mutex implementation uses atomic operations to ensure thread-safe locking semantics.</p>"},{"location":"locking/#structure","title":"Structure","text":"<pre><code>pub const Mutex = struct {\n    locked: atomic.Value(bool) = atomic.Value(bool).init(false),\n};\n</code></pre> <p>The mutex contains a single atomic boolean value that tracks the lock state:</p> <ul> <li><code>false</code> \u2014 The mutex is unlocked and available</li> <li><code>true</code> \u2014 The mutex is locked and owned by a task</li> </ul>"},{"location":"locking/#api","title":"API","text":"Function Description <code>init()</code> Creates a new unlocked mutex <code>lock()</code> Acquires the mutex, blocking until available <code>trylock()</code> Attempts to acquire the mutex without blocking <code>unlock()</code> Releases the mutex"},{"location":"locking/#usage","title":"Usage","text":""},{"location":"locking/#initialization","title":"Initialization","text":"<pre><code>var my_mutex = Mutex.init();\n</code></pre> <p>Or using the default initialization:</p> <pre><code>var my_mutex: Mutex = .{};\n</code></pre>"},{"location":"locking/#acquiring-the-lock","title":"Acquiring the Lock","text":"<pre><code>my_mutex.lock();\n// Critical section - access shared resource\nmy_mutex.unlock();\n</code></pre>"},{"location":"locking/#non-blocking-acquisition","title":"Non-blocking Acquisition","text":"<pre><code>if (my_mutex.trylock()) {\n    // Successfully acquired the lock\n    // Critical section\n    my_mutex.unlock();\n} else {\n    // Lock was not available\n}\n</code></pre>"},{"location":"locking/#implementation-details","title":"Implementation Details","text":""},{"location":"locking/#lock-operation","title":"Lock Operation","text":"<p>The <code>lock()</code> function uses an atomic swap operation with acquire memory ordering to atomically set the lock state to <code>true</code> while retrieving the previous value:</p> <pre><code>pub fn lock(self: *Mutex) void {\n    while (self.locked.swap(true, .acquire)) {\n        reschedule();\n    }\n}\n</code></pre> <p>If the previous value was <code>true</code> (already locked), the task yields execution by calling <code>reschedule()</code>, allowing other tasks to run. This continues until the lock is successfully acquired.</p> <p>Cooperative Yielding</p> <p>Unlike traditional spinlocks that busy-wait, KFS mutexes cooperatively yield to the scheduler when contention is detected. This prevents CPU waste and ensures fair scheduling among tasks.</p>"},{"location":"locking/#try-lock-operation","title":"Try Lock Operation","text":"<p>The <code>trylock()</code> function attempts a single lock acquisition without blocking:</p> <pre><code>pub fn trylock(self: *Mutex) bool {\n    return !self.locked.swap(true, .acquire);\n}\n</code></pre> <p>Returns <code>true</code> if the lock was successfully acquired, <code>false</code> otherwise.</p>"},{"location":"locking/#unlock-operation","title":"Unlock Operation","text":"<p>The <code>unlock()</code> function releases the mutex using release memory ordering:</p> <pre><code>pub fn unlock(self: *Mutex) void {\n    self.locked.store(false, .release);\n    reschedule();\n}\n</code></pre> <p>After releasing the lock, the function calls <code>reschedule()</code> to give other waiting tasks an opportunity to acquire the lock promptly.</p>"},{"location":"signals/","title":"Signals","text":"<p>A signal is an asynchronous notification sent to a process or to a specific thread  within the same process to notify it of an event. Common uses of signals are to  interrupt, suspend, terminate or kill a process.</p> <p>In KFS signals cannot be queued but user-provided signal handlers can run nested. The amount of handlers that can run nested is not limited by the kernel. The programmer is responsible for using good coding practices and common sense.</p> <p>KFS implements the following flags for sigaction</p> <ul> <li>SA_NODEFER   Do not add the signal to the thread's signal mask while the                 handler is executing, unless the signal is specified in                 act.sa_mask</li> <li> <p>SA_RESETHAND   Resets the handler of the signal to default when execution of that handler starts.</p> </li> <li> <p>SA_SIGINFO   sa_sigaction specifies the signal-handling function for signum.                     This function receives three arguments,</p> </li> </ul>"},{"location":"signals/#execution","title":"Execution","text":"<p>Everytime that there is a transition from kernel-mode to user-mode the kernel checks if there is an unblocked signal, that the process has established a custom handler for. If there is such a pending signal the following steps take place.</p> <ol> <li> <p>The kernel clears the bit of the signal from the pending signals.</p> <ul> <li>Various information regarding the signal context are saved into a frame that is created on the stack.</li> <li>The register context to restore the task once the handler is finished.</li> <li> <p>The signal number.</p> </li> <li> <p>Any signals specified in act-&gt;sa_mask when registering                the handler with sigaction) are added to the                task's signal mask.  The signal being delivered is                also added to the signal mask, unless SA_NODEFER was                specified when registering the handler. These signals                are thus blocked while the handler executes.</p> </li> </ul> </li> <li> <p>The kernel sets the program counter for the task to point to the first instruction of the signal handler function and set the return address for  this handler to point to a user-space piece of code known as the signal  trampoline (calls sigreturn).</p> </li> <li> <p>The kernel passes back control to user-space, and execution starts at the beggining of the signal handler function.</p> </li> <li> <p>When the handler returns, the signal trampoline code is executed.</p> </li> <li> <p>The signal trampoline calls sigreturn, which uses the information stored on the stack to restore the task to its state before the signal handler was  called. The tasks signal mask is restored during this procedure. Upon completion of sigreturn, the kernel transfers control back to user space,  and the task recommences execution at the point where it was interrupted  by the signal handler.</p> </li> </ol>"},{"location":"signals/#standard-signals","title":"Standard Signals","text":"<p>KFS supports the standard signals listed below:</p> Signal Value Action SIGHUP 1 Term SIGINT 2 Term SIGQUIT 3 Core SIGILL 4 Core SIGTRAP 5 Core SIGABRT 6 Core SIGIOT 6 Core SIGBUS 7 Core SIGFPE 8 Core SIGKILL 9 Term SIGUSR1 10 Term SIGSEGV 11 Core SIGUSR2 12 Term SIGPIPE 13 Term SIGALRM 14 Term SIGTERM 15 Term SIGSTKFLT 16 Term SIGCHLD 17 Ign SIGCONT 18 Cont SIGSTOP 19 Stop SIGTSTP 20 Stop SIGTTIN 21 Stop SIGTTOU 22 Stop SIGURG 23 Ign SIGXCPU 24 Core SIGXFSZ 25 Core SIGVTALRM 26 Term SIGPROF 27 Term SIGWINCH 28 Ign SIGIO 29 Term SIGPWR 30 Term SIGSYS 31 Core SIGUNUSED 31 Core"},{"location":"signals/#queuing","title":"Queuing","text":"<p>If multiple standard signals are pending for a process, the order        in which the signals are delivered is unspecified.</p> <p>Standard signals do not queue.  If multiple instances of a standard signal are generated while that signal is blocked, then only one instance of the signal is marked as pending (and the signal will be delivered just once when it is unblocked).</p>"},{"location":"signals/#interruption-of-system-calls","title":"Interruption of system calls","text":"<p>If a signal handler is invoked while a system call or library function call is blocked, then:</p> <ul> <li>the call fails with the error EINTR.  </li> </ul> <p>Support for SA_RESTART is coming in the future.</p>"},{"location":"signals/#syscalls","title":"Syscalls","text":"<p>KFS supports the following signal-related syscalls.</p> <ul> <li>sigaction</li> <li>rt_sigaction</li> <li>kill</li> <li>sigpending</li> <li>rt_sigpending</li> <li>sigprocmask</li> <li>rt_sigprocmask</li> <li>sigreturn</li> </ul>"}]}